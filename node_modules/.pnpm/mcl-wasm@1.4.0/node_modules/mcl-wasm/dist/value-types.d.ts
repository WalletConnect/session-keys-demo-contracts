declare abstract class Common {
    constructor(size: number);
    deserializeHexStr(s: string): void;
    serializeToHexStr(): string;
    dump(msg?: string): void;
    clear(): void;
    copyToMem(pos: number): void;
    copyFromMem(pos: number): void;
    abstract setStr(s: string, base?: number): void;
    abstract getStr(base?: number): string;
    abstract isEqual(rhs: this): boolean;
    abstract isZero(): boolean;
    abstract deserialize(v: Uint8Array): void;
    abstract serialize(): Uint8Array;
    abstract setHashOf(a: string | Uint8Array): void;
}
declare abstract class IntType extends Common {
    abstract setInt(x: number): void;
    abstract isOne(): boolean;
    abstract setLittleEndian(a: Uint8Array): void;
    abstract setLittleEndianMod(a: Uint8Array): void;
    abstract setBigEndianMod(a: Uint8Array): void;
    abstract setByCSPRNG(): void;
}
export declare class Fr extends IntType {
    constructor();
    setInt(x: number): void;
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    setStr(s: string, base?: number): void;
    getStr(base?: number): string;
    isZero(): boolean;
    isOne(): boolean;
    isEqual(rhs: this): boolean;
    setLittleEndian(a: Uint8Array): void;
    setLittleEndianMod(a: Uint8Array): void;
    setBigEndianMod(a: Uint8Array): void;
    setByCSPRNG(): void;
    setHashOf(s: string | Uint8Array): void;
}
export interface Fr {
    /** to distinct Fp and Fr for typescript */
    __Fr: never;
}
export declare const deserializeHexStrToFr: (s: string) => Fr;
export declare class Fp extends IntType {
    constructor();
    setInt(x: number): void;
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    setStr(s: string, base?: number): void;
    getStr(base?: number): string;
    isOne(): boolean;
    isZero(): boolean;
    isEqual(rhs: this): boolean;
    setLittleEndian(a: Uint8Array): void;
    setLittleEndianMod(a: Uint8Array): void;
    setBigEndianMod(a: Uint8Array): void;
    setByCSPRNG(): void;
    setHashOf(s: string | Uint8Array): void;
    mapToG1(): G1;
}
export interface Fp {
    /** to distinct Fp and Fr for typescript */
    __Fp: never;
}
export declare const deserializeHexStrToFp: (s: string) => Fp;
export declare class Fp2 extends Common {
    constructor();
    setInt(x: number, y: number): void;
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    getStr(base?: number): string;
    setStr(s: string, base?: number): void;
    isEqual(rhs: this): boolean;
    isZero(): boolean;
    setHashOf(s: string | Uint8Array): void;
    get_a(): Fp;
    get_b(): Fp;
    set_a(v: Fp): void;
    set_b(v: Fp): void;
    mapToG2(): G2;
}
export declare const deserializeHexStrToFp2: (s: string) => Fp2;
declare abstract class EllipticType extends Common {
    abstract normalize(): void;
    abstract isValid(): boolean;
    abstract isValidOrder(): boolean;
}
export declare class G1 extends EllipticType {
    constructor();
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    setStr(s: string, base?: number): void;
    getStr(base?: number): string;
    normalize(): void;
    getX(): Fp;
    getY(): Fp;
    getZ(): Fp;
    setX(v: Fp): void;
    setY(v: Fp): void;
    setZ(v: Fp): void;
    isZero(): boolean;
    isValid(): boolean;
    isValidOrder(): boolean;
    isEqual(rhs: this): boolean;
    setHashOf(s: string | Uint8Array): void;
}
export declare const deserializeHexStrToG1: (s: string) => G1;
export declare const setETHserialization: (ETHserialization: boolean) => void;
export declare const setMapToMode: (mode: number) => void;
export declare const verifyOrderG1: (doVerify: boolean) => void;
export declare const verifyOrderG2: (doVerify: boolean) => void;
export declare const getBasePointG1: () => G1;
export declare class G2 extends EllipticType {
    constructor();
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    setStr(s: string, base?: number): void;
    getStr(base?: number): string;
    normalize(): void;
    getX(): Fp2;
    getY(): Fp2;
    getZ(): Fp2;
    setX(v: Fp2): void;
    setY(v: Fp2): void;
    setZ(v: Fp2): void;
    isZero(): boolean;
    isValid(): boolean;
    isValidOrder(): boolean;
    isEqual(rhs: this): boolean;
    setHashOf(s: string | Uint8Array): void;
}
export declare const deserializeHexStrToG2: (s: string) => G2;
export declare class GT extends Common {
    constructor();
    setInt(x: number): void;
    deserialize(s: Uint8Array): void;
    serialize(): Uint8Array;
    setStr(s: string, base?: number): void;
    getStr(base?: number): string;
    isZero(): boolean;
    isOne(): boolean;
    isEqual(rhs: this): boolean;
    setHashOf(s: string | Uint8Array): void;
}
export declare const deserializeHexStrToGT: (s: string) => GT;
export declare class PrecomputedG2 {
    constructor(Q: G2);
    destroy(): void;
}
export declare const neg: <T extends Fr | Fp | G1 | Fp2 | G2 | GT>(x: T) => T;
export declare const sqr: <T extends Fr | Fp | Fp2 | GT>(x: T) => T;
export declare const inv: <T extends Fr | Fp | Fp2 | GT>(x: T) => T;
export declare const normalize: <T extends G1 | G2>(x: T) => T;
export declare const add: <T extends Fr | Fp | G1 | Fp2 | G2 | GT>(x: T, y: T) => T;
export declare const sub: <T extends Fr | Fp | G1 | Fp2 | G2 | GT>(x: T, y: T) => T;
export declare function mul(x: Fr, y: Fr): Fr;
export declare function mul(x: Fp, y: Fp): Fp;
export declare function mul(x: Fp2, y: Fp2): Fp2;
export declare function mul(x: G1, y: Fr): G1;
export declare function mul(x: G2, y: Fr): G2;
export declare function mul(x: GT, y: GT): GT;
export declare const mulVec: <T extends G1 | G2>(xVec: T[], yVec: Fr[]) => T;
export declare function div(x: Fr, y: Fr): Fr;
export declare function div(x: Fp, y: Fp): Fp;
export declare function div(x: Fp2, y: Fp2): Fp2;
export declare function div(x: GT, y: GT): GT;
export declare const dbl: <T extends G1 | G2>(x: T) => T;
export declare const hashToFr: (s: string | Uint8Array) => Fr;
export declare const hashAndMapToG1: (s: string | Uint8Array) => G1;
export declare const hashAndMapToG2: (s: string | Uint8Array) => G2;
export declare const pow: (x: GT, y: Fr) => GT;
export declare const pairing: (P: G1, Q: G2) => GT;
export declare const millerLoop: (P: G1, Q: G2) => GT;
export declare const precomputedMillerLoop: (P: G1, Qcoeff: PrecomputedG2) => GT;
export declare const precomputedMillerLoop2: (P1: G1, Q1coeff: PrecomputedG2, P2: G1, Q2coeff: PrecomputedG2) => GT;
export declare const precomputedMillerLoop2mixed: (P1: G1, Q1: G2, P2: G1, Q2coeff: PrecomputedG2) => GT;
export declare const finalExp: (x: GT) => GT;
export declare const shareFr: (vec: Fr[], id: Fr) => Fr;
export declare const shareG1: (vec: G1[], id: Fr) => G1;
export declare const shareG2: (vec: G2[], id: Fr) => G2;
export declare const recoverFr: (idVec: Fr[], yVec: Fr[]) => Fr;
export declare const recoverG1: (idVec: Fr[], yVec: G1[]) => G1;
export declare const recoverG2: (idVec: Fr[], yVec: G2[]) => G2;
export {};

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeMcl = exports.initializedCurveType = exports.free = exports.fromHexStr = exports.toHexStr = exports.toHex = exports.asciiStrToPtr = exports.ptrToAsciiStr = exports._free = exports._malloc = exports.mod = void 0;
const getRandomValues_1 = __importDefault(require("./getRandomValues"));
const constants_1 = require("./constants");
const createModule = require("./mcl_c.js");
/** @internal */
const _malloc = (size) => {
    return exports.mod._mclBnMalloc(size);
};
exports._malloc = _malloc;
/** @internal */
const _free = (pos) => {
    exports.mod._mclBnFree(pos);
};
exports._free = _free;
const ptrToAsciiStr = (pos, n) => {
    let s = '';
    for (let i = 0; i < n; i++) {
        s += String.fromCharCode(exports.mod.HEAP8[pos + i]);
    }
    return s;
};
exports.ptrToAsciiStr = ptrToAsciiStr;
const asciiStrToPtr = (pos, s) => {
    for (let i = 0; i < s.length; i++) {
        exports.mod.HEAP8[pos + i] = s.charCodeAt(i);
    }
};
exports.asciiStrToPtr = asciiStrToPtr;
const toHex = (a, start, n) => {
    let s = '';
    for (let i = 0; i < n; i++) {
        s += ('0' + a[start + i].toString(16)).slice(-2);
    }
    return s;
};
exports.toHex = toHex;
// Uint8Array to hex string
const toHexStr = (a) => {
    return (0, exports.toHex)(a, 0, a.length);
};
exports.toHexStr = toHexStr;
// hex string to Uint8Array
const fromHexStr = (s) => {
    if ((s.length & 1) !== 0)
        throw new Error(`fromHexStr:length must be even (${s.length})`);
    const n = s.length / 2;
    const a = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
        a[i] = parseInt(s.slice(i * 2, i * 2 + 2), 16);
    }
    return a;
};
exports.fromHexStr = fromHexStr;
const free = (x) => {
    (0, exports._free)(x);
};
exports.free = free;
const addWrappedMethods = () => {
    const _wrapGetStr = (func, returnAsStr = true) => {
        return (x, ioMode = 0) => {
            const maxBufSize = 3096;
            const pos = (0, exports._malloc)(maxBufSize);
            const n = func(pos, maxBufSize, x, ioMode);
            if (n <= 0) {
                throw new Error(`err gen_str:${x}`);
            }
            let s = null;
            if (returnAsStr) {
                s = (0, exports.ptrToAsciiStr)(pos, n);
            }
            else {
                s = new Uint8Array(exports.mod.HEAP8.subarray(pos, pos + n));
            }
            (0, exports._free)(pos);
            return s;
        };
    };
    const _wrapSerialize = (func) => {
        return _wrapGetStr(func, false);
    };
    const _wrapDeserialize = (func) => {
        return (x, buf) => {
            const pos = (0, exports._malloc)(buf.length);
            exports.mod.HEAP8.set(buf, pos);
            const r = func(x, pos, buf.length);
            (0, exports._free)(pos);
            if (r === 0 || r !== buf.length)
                throw new Error(`err _wrapDeserialize: ${r} != ${buf.length}`);
        };
    };
    /*
      argNum : n
      func(x0, ..., x_(n-1), buf, ioMode)
      => func(x0, ..., x_(n-1), pos, buf.length, ioMode)
    */
    const _wrapInput = (func, argNum) => {
        return function (...args) {
            const buf = args[argNum];
            const typeStr = Object.prototype.toString.apply(buf);
            if (!['[object String]', '[object Uint8Array]', '[object Array]'].includes(typeStr)) {
                throw new Error(`err bad type:"${typeStr}". Use String or Uint8Array.`);
            }
            const ioMode = args[argNum + 1]; // may undefined
            const pos = (0, exports._malloc)(buf.length);
            if (typeStr === '[object String]') {
                (0, exports.asciiStrToPtr)(pos, buf);
            }
            else {
                exports.mod.HEAP8.set(buf, pos);
            }
            const r = func(...args.slice(0, argNum), pos, buf.length, ioMode);
            (0, exports._free)(pos);
            if (r !== 0)
                throw new Error('err _wrapInput');
        };
    };
    exports.mod.mclBnFr_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_FR_SIZE);
    };
    exports.mod.mclBnFr_setLittleEndian = _wrapInput(exports.mod._mclBnFr_setLittleEndian, 1);
    exports.mod.mclBnFr_setLittleEndianMod = _wrapInput(exports.mod._mclBnFr_setLittleEndianMod, 1);
    exports.mod.mclBnFr_setBigEndianMod = _wrapInput(exports.mod._mclBnFr_setBigEndianMod, 1);
    exports.mod.mclBnFr_setStr = _wrapInput(exports.mod._mclBnFr_setStr, 1);
    exports.mod.mclBnFr_getStr = _wrapGetStr(exports.mod._mclBnFr_getStr);
    exports.mod.mclBnFr_deserialize = _wrapDeserialize(exports.mod._mclBnFr_deserialize);
    exports.mod.mclBnFr_serialize = _wrapSerialize(exports.mod._mclBnFr_serialize);
    exports.mod.mclBnFr_setHashOf = _wrapInput(exports.mod._mclBnFr_setHashOf, 1);
    /// ////////////////////////////////////////////////////////////
    exports.mod.mclBnFp_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_FP_SIZE);
    };
    exports.mod.mclBnFp_setLittleEndian = _wrapInput(exports.mod._mclBnFp_setLittleEndian, 1);
    exports.mod.mclBnFp_setLittleEndianMod = _wrapInput(exports.mod._mclBnFp_setLittleEndianMod, 1);
    exports.mod.mclBnFp_setBigEndianMod = _wrapInput(exports.mod._mclBnFp_setBigEndianMod, 1);
    exports.mod.mclBnFp_setStr = _wrapInput(exports.mod._mclBnFp_setStr, 1);
    exports.mod.mclBnFp_getStr = _wrapGetStr(exports.mod._mclBnFp_getStr);
    exports.mod.mclBnFp_deserialize = _wrapDeserialize(exports.mod._mclBnFp_deserialize);
    exports.mod.mclBnFp_serialize = _wrapSerialize(exports.mod._mclBnFp_serialize);
    exports.mod.mclBnFp_setHashOf = _wrapInput(exports.mod._mclBnFp_setHashOf, 1);
    exports.mod.mclBnFp2_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_FP_SIZE * 2);
    };
    exports.mod.mclBnFp2_deserialize = _wrapDeserialize(exports.mod._mclBnFp2_deserialize);
    exports.mod.mclBnFp2_serialize = _wrapSerialize(exports.mod._mclBnFp2_serialize);
    /// ////////////////////////////////////////////////////////////
    exports.mod.mclBnG1_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_G1_SIZE);
    };
    exports.mod.mclBnG1_setStr = _wrapInput(exports.mod._mclBnG1_setStr, 1);
    exports.mod.mclBnG1_getStr = _wrapGetStr(exports.mod._mclBnG1_getStr);
    exports.mod.mclBnG1_deserialize = _wrapDeserialize(exports.mod._mclBnG1_deserialize);
    exports.mod.mclBnG1_serialize = _wrapSerialize(exports.mod._mclBnG1_serialize);
    exports.mod.mclBnG1_hashAndMapTo = _wrapInput(exports.mod._mclBnG1_hashAndMapTo, 1);
    /// ////////////////////////////////////////////////////////////
    exports.mod.mclBnG2_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_G2_SIZE);
    };
    exports.mod.mclBnG2_setStr = _wrapInput(exports.mod._mclBnG2_setStr, 1);
    exports.mod.mclBnG2_getStr = _wrapGetStr(exports.mod._mclBnG2_getStr);
    exports.mod.mclBnG2_deserialize = _wrapDeserialize(exports.mod._mclBnG2_deserialize);
    exports.mod.mclBnG2_serialize = _wrapSerialize(exports.mod._mclBnG2_serialize);
    exports.mod.mclBnG2_hashAndMapTo = _wrapInput(exports.mod._mclBnG2_hashAndMapTo, 1);
    /// ////////////////////////////////////////////////////////////
    exports.mod.mclBnGT_malloc = () => {
        return (0, exports._malloc)(constants_1.MCLBN_GT_SIZE);
    };
    exports.mod.mclBnGT_deserialize = _wrapDeserialize(exports.mod._mclBnGT_deserialize);
    exports.mod.mclBnGT_serialize = _wrapSerialize(exports.mod._mclBnGT_serialize);
    exports.mod.mclBnGT_setStr = _wrapInput(exports.mod._mclBnGT_setStr, 1);
    exports.mod.mclBnGT_getStr = _wrapGetStr(exports.mod._mclBnGT_getStr);
};
const initializeMcl = (curveType = constants_1.CurveType.BN254) => __awaiter(void 0, void 0, void 0, function* () {
    exports.mod = yield createModule({
        cryptoGetRandomValues: (p, n) => {
            const a = new Uint8Array(n);
            (0, getRandomValues_1.default)(a);
            for (let i = 0; i < n; i++) {
                exports.mod.HEAP8[p + i] = a[i];
            }
        }
    });
    exports.initializedCurveType = curveType;
    addWrappedMethods();
    const r = exports.mod._mclBn_init(curveType, constants_1.MCLBN_COMPILED_TIME_VAR);
    if (r !== 0)
        throw new Error(`_mclBn_init err ${r}`);
});
exports.initializeMcl = initializeMcl;
